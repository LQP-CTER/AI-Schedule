# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import io  # Required for reading string data as file
import google.generativeai as genai
import yaml
from datetime import datetime, timedelta
# from config import GOOGLE_API_KEY # <<< REMOVED IMPORT
import re
import json
import sys  # Required for checking xlsxwriter
import numpy as np  # Needed for date calculations

# ------------------------------------------------------------------------------
# Page Configuration (Set Title and Icon)
st.set_page_config(page_title="AI Schedule Manager", page_icon="üìÖ", layout="wide")

# Check for xlsxwriter (optional but good for Excel export)
try:
    import xlsxwriter
except ImportError:
    st.warning("Module 'xlsxwriter' is recommended for Excel export. Install using: pip install xlsxwriter")

# --- UPDATED: Check and configure Google API Key using Streamlit Secrets ---
GOOGLE_API_KEY = st.secrets.get("GOOGLE_API_KEY")

if not GOOGLE_API_KEY:
    st.error("L·ªói: Google API Key ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh trong Streamlit Secrets!")
    st.info(
        "Vui l√≤ng th√™m GOOGLE_API_KEY v√†o m·ª•c Secrets trong c√†i ƒë·∫∑t ·ª©ng d·ª•ng c·ªßa b·∫°n tr√™n Streamlit Community Cloud.")
    st.stop()  # Stop execution if no API key

# Configure Google Generative AI
try:
    genai.configure(api_key=GOOGLE_API_KEY)
except Exception as e:
    st.error(f"L·ªói c·∫•u h√¨nh Google API: {e}");
    st.stop()

# Generation config for Google Generative AI
generation_config = {"temperature": 0.7, "top_p": 1, "top_k": 1, "max_output_tokens": 4096}

# Initialize the Generative Model
try:
    model = genai.GenerativeModel(model_name="gemini-2.5-flash",
                                  generation_config=generation_config)  # S·ª≠ d·ª•ng gemini-1.5-flash
except Exception as e:
    st.error(f"L·ªói kh·ªüi t·∫°o m√¥ h√¨nh AI: {e}");
    st.error("Ki·ªÉm tra API Key v√† k·∫øt n·ªëi m·∫°ng.");
    st.stop()

# --- Define Predefined Column Names ---
PREDEFINED_COLUMNS = [
    "T√™n nh√¢n vi√™n:",
    "ƒêƒÉng k√≠ ca cho tu·∫ßn:",
    "b·∫°n c√≥ th·ªÉ l√†m vi·ªác th·ªùi gian n√†o? [Th·ª© 2]",
    "b·∫°n c√≥ th·ªÉ l√†m vi·ªác th·ªùi gian n√†o? [Th·ª© 3]",
    "b·∫°n c√≥ th·ªÉ l√†m vi·ªác th·ªùi gian n√†o? [Th·ª© 4]",
    "b·∫°n c√≥ th·ªÉ l√†m vi·ªác th·ªùi gian n√†o? [Th·ª© 5]",
    "b·∫°n c√≥ th·ªÉ l√†m vi·ªác th·ªùi gian n√†o? [Th·ª© 6]",
    "b·∫°n c√≥ th·ªÉ l√†m vi·ªác th·ªùi gian n√†o? [Th·ª© 7]",
    "b·∫°n c√≥ th·ªÉ l√†m vi·ªác th·ªùi gian n√†o? [Ch·ªß nh·∫≠t]",
    "Ghi ch√∫ (n·∫øu c√≥)"
]


# --- Custom CSS for Styling (Keep as is) ---
def load_css():
    """Loads custom CSS styles."""
    # CSS content kept the same as previous version
    st.markdown("""
        <style>
            /* General Body and Font */
            body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
            /* Main Container */
            .main .block-container { padding-top: 2rem; padding-bottom: 5rem; padding-left: 2rem; padding-right: 2rem; } /* Reduced padding */
            /* Titles */
            h1, h2 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px; margin-bottom: 20px;}
            h3 { color: #34495e; margin-top: 25px; margin-bottom: 15px; }
            body:has([data-theme="dark"]) h1, body:has([data-theme="dark"]) h2, body:has([data-theme="dark"]) h3 { color: #ecf0f1; border-bottom-color: #5dade2;}
            body:has([data-theme="dark"]) h3 { color: #bdc3c7;}

            /* Buttons */
            .stButton>button { border-radius: 8px; padding: 10px 15px; font-weight: 600; border: none; color: white; background-color: #3498db; transition: background-color 0.3s ease; margin-top: 5px; margin-bottom: 5px;} /* Slightly less padding */
            .stButton>button:hover { background-color: #2980b9; }
            .stButton>button:active { background-color: #2471a3; }
            .stButton[key*="generate_ai_button"]>button { background-color: #2ecc71; }
            .stButton[key*="generate_ai_button"]>button:hover { background-color: #27ae60; }
            /* Button for copy text */
             .stButton[key*="generate_copy_text_button"]>button { background-color: #9b59b6; /* Purple */ }
             .stButton[key*="generate_copy_text_button"]>button:hover { background-color: #8e44ad; /* Darker Purple */ }


            /* Text Area */
            .stTextArea textarea { border-radius: 8px; border: 1px solid #bdc3c7; padding: 10px; min-height: 150px; font-family: monospace; /* Use monospace for better alignment */}
            body:has([data-theme="dark"]) .stTextArea textarea { border: 1px solid #566573; }
            .stTextArea label { font-weight: 600; color: #34495e; margin-bottom: 5px; display: block;}
            body:has([data-theme="dark"]) .stTextArea label { color: #bdc3c7; }

            /* DataFrames / Data Editor / Manual Table */
            .stDataFrame, .stDataEditor, .manual-table-header, .manual-table-row { border-radius: 8px; overflow: visible; margin-bottom: 10px;} /* Reduced margin */
            .manual-table-header > div { font-weight: bold; background-color: #eaf2f8; padding: 8px 6px; text-align: center; border: 1px solid #d6eaf8; font-size: 0.9rem;} /* Smaller padding/font */
            body:has([data-theme="dark"]) .manual-table-header > div { background-color: #34495e; border: 1px solid #4e6070; }
            .manual-table-row > div { padding: 4px 6px; border: 1px solid #e8ecf1; min-height: 55px; display: flex; align-items: center; justify-content: center;} /* Reduced padding */
            body:has([data-theme="dark"]) .manual-table-row > div { border: 1px solid #4a4f5a; }
            /* Alternating row colors for manual table */
            .manual-table-row:nth-child(even) > div { background-color: #f8f9fa; }
            body:has([data-theme="dark"]) .manual-table-row:nth-child(even) > div { background-color: #2c3e50; }


            /* Selectbox in manual table */
            .manual-table-row .stSelectbox { width: 100%; overflow: visible !important; }
            .manual-table-row .stSelectbox div[data-baseweb="select"] { font-size: 0.85rem; width: 100%; background-color: var(--background-color); }
            .manual-table-row .stSelectbox div[data-baseweb="select"] > div:first-child { color: var(--text-color) !important; overflow: visible !important; }
            .manual-table-row .stSelectbox div[data-baseweb="select"] > div:first-child > div { white-space: normal !important; overflow: visible !important; text-overflow: clip !important; max-width: none !important; }


            /* Sidebar */
             .stSidebar .stNumberInput input, .stSidebar .stSlider, .stSidebar .stCheckbox { margin-bottom: 10px; }
             .stSidebar h3 { color: #3498db; margin-top: 15px;}
             body:has([data-theme="dark"]) .stSidebar h3 { color: #5dade2; }
             .stSidebar .stMarkdown p { font-size: 0.95rem; line-height: 1.4;}
             .stSidebar .stDivider { margin-top: 15px; margin-bottom: 15px;}

            /* --- UPDATED: Footer style for sidebar --- */
            .footer-copyright {
                color: #7f8c8d; font-size: 12px; text-align: center; padding-top: 20px;
            }
             body:has([data-theme="dark"]) .footer-copyright { color: #95a5a6; }

            /* Login Box Specific Styles */
            .login-box { margin: 50px auto 0 auto; max-width: 380px; background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(5px); padding: 35px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); text-align: center; }
            .login-title { font-size: 24px; font-weight: 600; color: #31333F; margin-bottom: 25px; border-bottom: none; }
            .login-box .stTextInput>div>div>input { padding: 12px; border: 1px solid #ccc; border-radius: 5px; width: 100%; margin-bottom: 15px;}
            .login-box .stButton>button { width: 100%; height: 48px; background-color: #31333F; color: #FFFFFF; border: none; border-radius: 5px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 15px; }
            .login-box .stButton>button:hover { background-color: #50525C; }
            .login-page-background { background: linear-gradient(to right, #74ebd5, #ACB6E5); min-height: 100vh; width: 100%; display: flex; align-items: center; justify-content: center; position: absolute; top: 0; left: 0; z-index: -1; }

            /* Container styling */
            div[data-testid="stVerticalBlock"]:has(> div > div > div.stContainer) { }
             body:has([data-theme="dark"]) div[data-testid="stVerticalBlock"]:has(> div > div > div.stContainer) { }

        </style>
    """, unsafe_allow_html=True)


# --- Credential Loading and Login Logic ---
def load_credentials():
    """Loads credentials from Streamlit secrets or local file."""
    credentials_dict = st.secrets.get("credentials", {})
    if not credentials_dict:
        st.warning("Kh√¥ng t√¨m th·∫•y credentials trong Secrets. Th·ª≠ ƒë·ªçc file credentials.yaml...")
        try:
            with open('credentials.yaml') as file:
                credentials_dict = yaml.safe_load(file) or {}
        except FileNotFoundError:
            st.error("File credentials.yaml kh√¥ng t·ªìn t·∫°i."); return {}
        except yaml.YAMLError as e:
            st.error(f"L·ªói ƒë·ªçc credentials.yaml: {e}"); return {}
    return credentials_dict


def login():
    """Handles the login interface and logic."""
    if 'logged_in' not in st.session_state: st.session_state.logged_in = False
    st.markdown('<div class="login-page-background"></div>', unsafe_allow_html=True)
    col1, col2, col3 = st.columns([1, 1.5, 1])
    with col2:
        st.markdown("<div class='login-box'>", unsafe_allow_html=True)
        st.markdown("<h2 class='login-title'>AI Schedule Manager</h2>", unsafe_allow_html=True)
        st.markdown("<p style='color: #566573; margin-top: -15px; margin-bottom: 30px;'>Vui l√≤ng ƒëƒÉng nh·∫≠p</p>",
                    unsafe_allow_html=True)
        credentials = load_credentials();
        if not credentials: st.markdown("</div>", unsafe_allow_html=True); return False
        username = st.text_input("T√™n ƒëƒÉng nh·∫≠p", key="login_user").strip()
        password = st.text_input("M·∫≠t kh·∫©u", type="password", key="login_pass")
        if st.button("ƒêƒÉng nh·∫≠p", key="login_button_main", use_container_width=True):
            if username in credentials and credentials[username] == password:
                st.session_state.logged_in = True;
                st.success("ƒêƒÉng nh·∫≠p th√†nh c√¥ng!");
                st.rerun()
            else:
                st.error("T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng.")
        st.markdown("</div>", unsafe_allow_html=True)
    return st.session_state.logged_in


# --- Scheduling Requirements Input ---
def get_scheduling_requirements():
    """Gets scheduling constraints from the sidebar."""
    st.sidebar.header("‚öôÔ∏è ƒêi·ªÅu Ki·ªán L·∫≠p L·ªãch")
    st.sidebar.divider()
    requirements = {
        "shifts_definition": {"Ca 1": {"start": "09:00", "end": "15:00"}, "Ca 2": {"start": "14:00", "end": "20:00"}},
        "max_shifts_per_day": 1,
        "shifts_per_week_target": 4,  # M·ª•c ti√™u s·ªë ca m·ªói tu·∫ßn
        "min_rest_hours": st.sidebar.number_input("Gi·ªù ngh·ªâ t·ªëi thi·ªÉu (>1 ca/ng√†y)", min_value=1, value=8, step=1),
        "max_consecutive_days": st.sidebar.number_input("Ng√†y l√†m li√™n ti·∫øp t·ªëi ƒëa", min_value=1, max_value=7, value=6,
                                                        step=1),
        "preferences_weight_hint": st.sidebar.slider("∆Øu ti√™n nguy·ªán v·ªçng ghi ch√∫", 0.0, 1.0, 0.7, 0.1)
    }
    st.sidebar.divider();
    st.sidebar.markdown("**‚ÑπÔ∏è Quy t·∫Øc:**")
    st.sidebar.markdown(
        f"- **Ca 1:** {requirements['shifts_definition']['Ca 1']['start']} - {requirements['shifts_definition']['Ca 1']['end']}")
    st.sidebar.markdown(
        f"- **Ca 2:** {requirements['shifts_definition']['Ca 2']['start']} - {requirements['shifts_definition']['Ca 2']['end']}")
    st.sidebar.markdown(f"- **S·ªë ng∆∞·ªùi/ca:** **2** (ng√†y th∆∞·ªùng), **3** (ng√†y tr√πng th√°ng VD: 3/3, 5/5...)")
    st.sidebar.markdown(f"- **T·ªëi ƒëa:** **{requirements['max_shifts_per_day']}** ca/ng∆∞·ªùi/ng√†y")
    st.sidebar.markdown(
        f"- **T·ªïng s·ªë ca/tu·∫ßn (M·ª•c ti√™u):** **{requirements['shifts_per_week_target']}** ca/ng∆∞·ªùi")  # Hi·ªÉn th·ªã m·ª•c ti√™u
    st.sidebar.divider()
    if not requirements["min_rest_hours"] > 0 or not requirements["max_consecutive_days"] > 0:
        st.sidebar.error("Gi·ªù ngh·ªâ v√† ng√†y l√†m li√™n ti·∫øp ph·∫£i l·ªõn h∆°n 0.");
        return None
    return requirements


# --- Helper Function to Find Start Date (Keep updated date parsing) ---
def find_start_date(df_input):
    """Finds the start date (Monday) from the input DataFrame."""
    week_start_col = next((col for col in df_input.columns if 'tu·∫ßn' in col.lower() or 'week' in col.lower()), None)
    start_date = None
    if week_start_col and not df_input[week_start_col].empty:
        date_val_str = str(df_input[week_start_col].dropna().iloc[0])  # Get value as string
        try:
            # Th·ª≠ ƒë·ªãnh d·∫°ng DD/MM/YYYY tr∆∞·ªõc
            start_date = pd.to_datetime(date_val_str, format='%d/%m/%Y', errors='coerce')
            if pd.isna(start_date):  # N·∫øu th·∫•t b·∫°i, th·ª≠ ƒë·ªãnh d·∫°ng MM/DD/YYYY
                start_date = pd.to_datetime(date_val_str, format='%m/%d/%Y', errors='coerce')
            if pd.isna(start_date):  # N·∫øu v·∫´n th·∫•t b·∫°i, th·ª≠ ƒë·ªãnh d·∫°ng YYYY-MM-DD
                start_date = pd.to_datetime(date_val_str, format='%Y-%m-%d', errors='coerce')
            if pd.isna(start_date):  # N·∫øu v·∫´n th·∫•t b·∫°i, ƒë·ªÉ pandas t·ª± ƒë·ªông ph√°t hi·ªán
                start_date = pd.to_datetime(date_val_str, errors='coerce')

            if pd.notna(start_date):
                start_date = start_date - timedelta(days=start_date.weekday())  # L√πi v·ªÅ th·ª© 2 ƒë·∫ßu tu·∫ßn
        except Exception as e:
            st.warning(f"L·ªói ph√¢n t√≠ch ng√†y th√°ng t·ª´ c·ªôt '{week_start_col}': {e}. Gi√° tr·ªã: '{date_val_str}'");
            pass
    return start_date


# --- RE-ADD: Preprocess Pasted Data for Availability Lookup ---
def preprocess_pasted_data_for_lookup(df_input):
    """Processes the raw pasted DataFrame to create a structured availability lookup table."""
    st.info("‚öôÔ∏è ƒêang x·ª≠ l√Ω d·ªØ li·ªáu ƒëƒÉng k√Ω g·ªëc ƒë·ªÉ tra c·ª©u...")
    processed_rows = []
    start_date = find_start_date(df_input)
    if start_date is None:
        st.warning("‚ö†Ô∏è Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ng√†y b·∫Øt ƒë·∫ßu tu·∫ßn. Ch·ª©c nƒÉng t√¨m thay th·∫ø s·∫Ω kh√¥ng ho·∫°t ƒë·ªông.")
        return pd.DataFrame(columns=['Date', 'Employee', 'Shift', 'Can_Work', 'Note'])  # Return empty DF

    employee_col = next((col for col in df_input.columns if 't√™n' in col.lower()), None)
    note_col = next((col for col in df_input.columns if 'ghi ch√∫' in col.lower()), None)
    day_mapping = {};
    day_keywords_map = {
        0: ['th·ª© 2', 'mon'], 1: ['th·ª© 3', 'tue'], 2: ['th·ª© 4', 'wed'], 3: ['th·ª© 5', 'thu'],
        4: ['th·ª© 6', 'fri'], 5: ['th·ª© 7', 'sat'], 6: ['ch·ªß nh·∫≠t', 'sun', 'cn']  # Th√™m 'cn'
    }
    found_day_cols = False
    for day_index, keywords in day_keywords_map.items():
        for col in df_input.columns:
            col_lower = str(col).lower()
            # --- More specific check for day columns, allowing for variations ---
            if any(f'[{keyword}]' in col_lower for keyword in keywords) or \
                    any(f' {keyword}' in col_lower for keyword in keywords) or \
                    any(keyword == col_lower.replace("b·∫°n c√≥ th·ªÉ l√†m vi·ªác th·ªùi gian n√†o?", "").strip().replace("[",
                                                                                                               "").replace(
                        "]", "") for keyword in keywords):
                day_mapping[day_index] = col;
                found_day_cols = True;
                break
    if not found_day_cols: st.error(
        "‚ùå Kh√¥ng t√¨m th·∫•y c√°c c·ªôt ng√†y (VD: '... [Th·ª© 2]'). Ki·ªÉm tra l·∫°i t√™n c·ªôt."); return None
    if not employee_col: st.error("‚ùå Kh√¥ng t√¨m th·∫•y c·ªôt t√™n nh√¢n vi√™n."); return None

    for index, row in df_input.iterrows():
        employee = row.get(employee_col);
        note = row.get(note_col, '') if note_col else ''
        if not employee or pd.isna(employee): continue
        for day_index, day_col in day_mapping.items():
            current_date = start_date + timedelta(days=day_index)
            availability_text = str(row.get(day_col, '')).lower()
            can_do_ca1 = False;
            can_do_ca2 = False
            if 'ngh·ªâ' in availability_text or 'off' in availability_text or 'b·∫≠n' in availability_text:
                pass  # Both remain False
            else:
                if 'ca 1' in availability_text or 's√°ng' in availability_text or '9h' in availability_text or '9:00' in availability_text: can_do_ca1 = True
                if 'ca 2' in availability_text or 'chi·ªÅu' in availability_text or '14h' in availability_text or '2h' in availability_text or '14:00' in availability_text: can_do_ca2 = True
                # If text exists but doesn't specify shift, assume both possible unless explicitly 'nghi'
                if not can_do_ca1 and not can_do_ca2 and availability_text.strip() != '' and not any(
                        x in availability_text for x in ['ngh·ªâ', 'off', 'b·∫≠n']):
                    can_do_ca1 = True;
                    can_do_ca2 = True
            processed_rows.append({'Date': current_date.date(), 'Employee': str(employee).strip(), 'Shift': 'Ca 1',
                                   'Can_Work': can_do_ca1, 'Note': note})
            processed_rows.append({'Date': current_date.date(), 'Employee': str(employee).strip(), 'Shift': 'Ca 2',
                                   'Can_Work': can_do_ca2, 'Note': note})
    if not processed_rows: st.warning("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ƒëƒÉng k√Ω h·ª£p l·ªá."); return pd.DataFrame(
        columns=['Date', 'Employee', 'Shift', 'Can_Work', 'Note'])
    lookup_df = pd.DataFrame(processed_rows)
    lookup_df['Date'] = pd.to_datetime(lookup_df['Date']).dt.date  # Ensure Date is date object
    st.success("‚úÖ ƒê√£ x·ª≠ l√Ω xong d·ªØ li·ªáu ƒëƒÉng k√Ω g·ªëc.");
    return lookup_df


# --- AI Schedule Generation Function (UPDATED PROMPT with reinforced Double Day rule) ---
def generate_schedule_with_ai(df_input, requirements, model):
    """Constructs a prompt and calls the AI model to generate the schedule."""
    st.info(" Chu·∫©n b·ªã d·ªØ li·ªáu v√† t·∫°o prompt cho AI...")
    data_prompt_list = [];
    data_prompt_list.append("D·ªØ li·ªáu ƒëƒÉng k√Ω c·ªßa nh√¢n vi√™n:")
    employee_col = next((col for col in df_input.columns if 't√™n' in col.lower()), None)
    note_col = next((col for col in df_input.columns if 'ghi ch√∫' in col.lower()), None)
    day_keywords = ['th·ª© 2', 'th·ª© 3', 'th·ª© 4', 'th·ª© 5', 'th·ª© 6', 'th·ª© 7', 'ch·ªß nh·∫≠t', 'mon', 'tue', 'wed', 'thu', 'fri',
                    'sat', 'sun', 'cn']
    day_cols_map = {}  # S·ª≠ d·ª•ng map ƒë·ªÉ gi·ªØ ƒë√∫ng th·ª© t·ª± ng√†y
    days_order = ["th·ª© 2", "th·ª© 3", "th·ª© 4", "th·ª© 5", "th·ª© 6", "th·ª© 7", "ch·ªß nh·∫≠t"]  # ho·∫∑c "cn"

    # T√¨m c·ªôt cho t·ª´ng ng√†y
    for day_name_vn in days_order:
        for col in df_input.columns:
            col_lower = str(col).lower()
            # Ki·ªÉm tra ch√≠nh x√°c h∆°n, v√≠ d·ª•: "[th·ª© 2]" ho·∫∑c "th·ª© 2" ·ªü cu·ªëi
            if f"[{day_name_vn}]" in col_lower or col_lower.endswith(day_name_vn) or day_name_vn in col_lower:
                day_cols_map[day_name_vn] = col
                break
    day_cols = [day_cols_map[d] for d in days_order if d in day_cols_map]  # L·∫•y c√°c c·ªôt theo ƒë√∫ng th·ª© t·ª±

    start_date = find_start_date(df_input);
    start_date_str_for_prompt = start_date.strftime('%Y-%m-%d') if start_date else "Kh√¥ng x√°c ƒë·ªãnh"
    if not employee_col: st.error("L·ªói: Kh√¥ng th·ªÉ x√°c ƒë·ªãnh c·ªôt 'T√™n nh√¢n vi√™n'."); return None
    if not day_cols: st.warning("Kh√¥ng t√¨m th·∫•y ƒë·ªß c√°c c·ªôt ng√†y (Th·ª© 2-CN). Ki·ªÉm tra l·∫°i t√™n c·ªôt trong file Excel.")
    if start_date is None: st.warning("Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ng√†y b·∫Øt ƒë·∫ßu tu·∫ßn.")

    data_prompt_list.append(f"(D·ªØ li·ªáu cho tu·∫ßn b·∫Øt ƒë·∫ßu Th·ª© 2 kho·∫£ng: {start_date_str_for_prompt})")
    for index, row in df_input.iterrows():  # Format data for prompt
        emp_name = row[employee_col];
        data_prompt_list.append(f"Nh√¢n vi√™n: {emp_name}")
        availability_info = []
        if day_cols:
            for day_col_name in day_cols:  # Duy·ªát theo th·ª© t·ª± ƒë√£ s·∫Øp x·∫øp
                cell_value = row.get(day_col_name)
                # L·∫•y t√™n ng√†y t·ª´ t√™n c·ªôt ƒë·ªÉ hi·ªÉn th·ªã (v√≠ d·ª•: "Th·ª© 2" t·ª´ "b·∫°n c√≥ th·ªÉ l√†m vi·ªác th·ªùi gian n√†o? [Th·ª© 2]")
                clean_day_name = day_col_name
                match = re.search(r'\[(.*?)\]', day_col_name)
                if match:
                    clean_day_name = match.group(1)
                elif any(d in day_col_name.lower() for d in days_order):
                    for d_keyword in days_order:
                        if d_keyword in day_col_name.lower():
                            clean_day_name = d_keyword.capitalize()
                            break

                if pd.notna(cell_value):
                    availability_info.append(f"- {clean_day_name}: {cell_value}")
                else:
                    availability_info.append(f"- {clean_day_name}: (Tr·ªëng)")
        else:
            availability_info.append(f"  (Th√¥ng tin chi ti·∫øt: {row.to_dict()})")
        data_prompt_list.extend(availability_info)
        if note_col and pd.notna(row.get(note_col)):
            data_prompt_list.append(f"- Ghi ch√∫: {row[note_col]}")
        else:
            data_prompt_list.append(f"- Ghi ch√∫: Kh√¥ng c√≥")
        data_prompt_list.append("---")
    data_prompt = "\n".join(data_prompt_list)

    daily_staffing_prompt = "- **Y√™u c·∫ßu s·ªë l∆∞·ª£ng nh√¢n vi√™n (Part-time) m·ªói ca:**\n"
    if start_date:
        for i in range(7):
            current_day = start_date + timedelta(days=i)
            staff_count = 3 if current_day.day == current_day.month else 2
            day_name_vn = ["Th·ª© 2", "Th·ª© 3", "Th·ª© 4", "Th·ª© 5", "Th·ª© 6", "Th·ª© 7", "Ch·ªß Nh·∫≠t"][i]
            daily_staffing_prompt += f"  + Ng√†y {current_day.strftime('%Y-%m-%d')} ({day_name_vn}): **{staff_count} ng∆∞·ªùi/ca** (Ca 1 v√† Ca 2).\n"
    else:
        daily_staffing_prompt += "  + **2 ng∆∞·ªùi/ca** cho t·∫•t c·∫£ c√°c ng√†y.\n"

    req_prompt_list = []  # Format requirements for prompt
    req_prompt_list.append("\nR√†ng bu·ªôc v√† Quy t·∫Øc x·∫øp l·ªãch:")
    req_prompt_list.append(
        f"- Ca l√†m vi·ªác: Ca 1 ({requirements['shifts_definition']['Ca 1']['start']} - {requirements['shifts_definition']['Ca 1']['end']}), Ca 2 ({requirements['shifts_definition']['Ca 2']['start']} - {requirements['shifts_definition']['Ca 2']['end']}).")
    req_prompt_list.append(f"- M·ªói nh√¢n vi√™n l√†m t·ªëi ƒëa {requirements['max_shifts_per_day']} ca/ng√†y.")
    # --- MODIFIED LINE (Rule for 4 shifts per week) ---
    req_prompt_list.append(
        f"- **M·ª§C TI√äU QUAN TR·ªåNG NH·∫§T (B·∫ÆT BU·ªòC TU√ÇN TH·ª¶):** Ph√¢n b·ªï ch√≠nh x√°c **{requirements['shifts_per_week_target']} ca l√†m vi·ªác cho M·ªñI nh√¢n vi√™n** (tr·ª´ FM/Sup, ho·∫∑c nh·ªØng ng∆∞·ªùi c√≥ ghi ch√∫ 'ngh·ªâ c·∫£ tu·∫ßn' / 'xin ngh·ªâ nguy√™n tu·∫ßn' trong c·ªôt Ghi Ch√∫, ho·∫∑c nh·ªØng ng∆∞·ªùi kh√¥ng ƒëƒÉng k√Ω ƒë·ªß s·ªë bu·ªïi kh·∫£ d·ª•ng ƒë·ªÉ ƒë·∫°t {requirements['shifts_per_week_target']} ca). Vi·ªác n√†y ph·∫£i ƒë∆∞·ª£c ∆∞u ti√™n H√ÄNG ƒê·∫¶U, ch·ªâ sau vi·ªác t√¥n tr·ªçng c√°c ng√†y ƒëƒÉng k√Ω 'Ngh·ªâ' c·ª• th·ªÉ c·ªßa nh√¢n vi√™n (v√≠ d·ª•: 'Ngh·ªâ' trong c·ªôt c·ªßa Th·ª© 2 th√¨ kh√¥ng x·∫øp l·ªãch cho Th·ª© 2). N·∫øu kh√¥ng th·ªÉ ƒë·∫°t ƒë∆∞·ª£c m·ª•c ti√™u {requirements['shifts_per_week_target']} ca cho m·ªôt nh√¢n vi√™n n√†o ƒë√≥ (m√† h·ªç ƒë·ªß ƒëi·ªÅu ki·ªán), AI PH·∫¢I gi·∫£i th√≠ch r√µ r√†ng l√Ω do c·ª• th·ªÉ cho t·ª´ng tr∆∞·ªùng h·ª£p kh√¥ng ƒë·∫°t ƒë∆∞·ª£c trong ph·∫ßn ph·∫£n h·ªìi c·ªßa m√¨nh, ngay b√™n d∆∞·ªõi b·∫£ng l·ªãch.")
    req_prompt_list.append(f"- √çt nh·∫•t {requirements['min_rest_hours']} gi·ªù ngh·ªâ gi·ªØa c√°c ca (n·∫øu c√≥ th·ªÉ >1 ca/ng√†y).")
    req_prompt_list.append(f"- T·ªëi ƒëa {requirements['max_consecutive_days']} ng√†y l√†m vi·ªác li√™n ti·∫øp.")
    req_prompt_list.append(daily_staffing_prompt[:-1])  # Remove last newline
    req_prompt_list.append(
        "  + **L∆ØU √ù:** Ng√†y tr√πng th√°ng (v√≠ d·ª• 3/3, 5/5) c·∫ßn 3 ng∆∞·ªùi/ca, c√°c ng√†y kh√°c c·∫ßn 2 ng∆∞·ªùi/ca.")
    req_prompt_list.append(f"- X·ª≠ l√Ω 'Ghi ch√∫' c·ªßa nh√¢n vi√™n (trong c·ªôt 'Ghi ch√∫ (n·∫øu c√≥)'):")
    req_prompt_list.append(
        f"  + **∆Øu ti√™n 1 (B·∫Øt bu·ªôc):** N·∫øu c·ªôt 'Ghi ch√∫' ch·ª©a 'ngh·ªâ c·∫£ tu·∫ßn', 'xin ngh·ªâ nguy√™n tu·∫ßn', 'ngh·ªâ', 'b·∫≠n', 'kh√¥ng th·ªÉ', 'xin off' -> TUY·ªÜT ƒê·ªêI KH√îNG x·∫øp l·ªãch cho nh√¢n vi√™n ƒë√≥ trong c·∫£ tu·∫ßn (tr·ª´ khi ghi ch√∫ ch·ªâ r√µ ph·∫°m vi ng√†y c·ª• th·ªÉ).")
    req_prompt_list.append(
        f"  + **∆Øu ti√™n 2 (Mong mu·ªën):** N·∫øu c·ªôt 'Ghi ch√∫' ch·ª©a 'mu·ªën l√†m', '∆∞u ti√™n', 'c√≥ th·ªÉ l√†m' -> C·ªê G·∫ÆNG x·∫øp n·∫øu kh√¥ng vi ph·∫°m r√†ng bu·ªôc kh√°c (m·ª©c ƒë·ªô ∆∞u ti√™n g·ª£i √Ω: {requirements['preferences_weight_hint']}).")
    req_prompt_list.append(
        f"  + **∆Øu ti√™n 3 (Gi·ªù l√†m kh√¥ng tr·ªçn v·∫πn trong c·ªôt Ghi ch√∫):** N·∫øu c·ªôt 'Ghi ch√∫' c√≥ gi·ªù c·ª• th·ªÉ (VD: 'ch·ªâ l√†m 9h-12h', 'l√†m t·ª´ 16h'), h√£y l√†m theo c√°c b∆∞·ªõc sau:")
    req_prompt_list.append(
        f"      1. ∆Øu ti√™n x·∫øp ƒë·ªß s·ªë ng∆∞·ªùi c√≥ th·ªÉ l√†m **tr·ªçn v·∫πn** ca ƒë√≥ tr∆∞·ªõc (d·ª±a tr√™n ƒëƒÉng k√Ω c√°c c·ªôt ng√†y).")
    req_prompt_list.append(
        f"      2. **CH·ªà KHI** ca ƒë√≥ v·∫´n c√≤n thi·∫øu ng∆∞·ªùi theo y√™u c·∫ßu s·ªë l∆∞·ª£ng, th√¨ M·ªöI xem x√©t x·∫øp nh√¢n vi√™n c√≥ gi·ªù l√†m kh√¥ng tr·ªçn v·∫πn (theo c·ªôt Ghi ch√∫) v√†o ƒë·ªÉ ƒë√°p ·ª©ng nguy·ªán v·ªçng c·ªßa h·ªç (d√π h·ªç kh√¥ng l√†m ƒë·ªß gi·ªù).")
    req_prompt_list.append(
        f"      3. N·∫øu ca ƒë√£ ƒë·ªß ng∆∞·ªùi l√†m tr·ªçn v·∫πn, th√¨ KH√îNG x·∫øp th√™m ng∆∞·ªùi ch·ªâ l√†m ƒë∆∞·ª£c m·ªôt ph·∫ßn gi·ªù (theo c·ªôt Ghi ch√∫).")
    req_prompt_list.append(
        "- Ch·ªâ x·∫øp l·ªãch v√†o ca nh√¢n vi√™n ƒëƒÉng k√Ω/c√≥ th·ªÉ l√†m (d·ª±a tr√™n d·ªØ li·ªáu c√°c c·ªôt ng√†y Th·ª© 2 - Ch·ªß Nh·∫≠t).")
    req_prompt_list.append("- B·ªè qua nh√¢n vi√™n 'FM/Sup'.")
    req_prompt = "\n".join(req_prompt_list)

    full_prompt = f"""
B·∫°n l√† m·ªôt tr·ª£ l√Ω qu·∫£n l√Ω l·ªãch l√†m vi·ªác si√™u h·∫°ng. D·ª±a v√†o d·ªØ li·ªáu ƒëƒÉng k√Ω c·ªßa nh√¢n vi√™n (ch·ªß y·∫øu l√† Part-time) v√† c√°c quy t·∫Øc r√†ng bu·ªôc d∆∞·ªõi ƒë√¢y, h√£y t·∫°o ra m·ªôt l·ªãch l√†m vi·ªác t·ªëi ∆∞u cho tu·∫ßn, **b·∫Øt ƒë·∫ßu t·ª´ ng√†y Th·ª© Hai l√† {start_date_str_for_prompt} (YYYY-MM-DD)**.

{data_prompt}

{req_prompt}

**Y√™u c·∫ßu ƒë·∫ßu ra:**
H√£y tr√¨nh b√†y l·ªãch l√†m vi·ªác d∆∞·ªõi d·∫°ng m·ªôt b·∫£ng MARKDOWN r√µ r√†ng.
**C·ªôt ƒë·∫ßu ti√™n PH·∫¢I l√† "Ng√†y" v√† ch·ª©a ng√†y th√°ng c·ª• th·ªÉ (theo ƒë·ªãnh d·∫°ng YYYY-MM-DD)** cho t·ª´ng ng√†y trong tu·∫ßn (Th·ª© 2 ƒë·∫øn Ch·ªß Nh·∫≠t), t√≠nh to√°n d·ª±a tr√™n ng√†y b·∫Øt ƒë·∫ßu tu·∫ßn ƒë√£ cho ({start_date_str_for_prompt}).
C√°c c·ªôt ti·∫øp theo l√† "Ca" v√† "Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng". S·∫Øp x·∫øp theo ng√†y. **Trong c·ªôt "Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng", li·ªát k√™ T·∫§T C·∫¢ t√™n nh√¢n vi√™n ƒë∆∞·ª£c x·∫øp v√†o ca ƒë√≥, c√°ch nhau b·∫±ng d·∫•u ph·∫©y.**

V√≠ d·ª• ƒë·ªãnh d·∫°ng b·∫£ng MARKDOWN mong mu·ªën (v·ªõi ng√†y b·∫Øt ƒë·∫ßu l√† 2025-05-05, l√† ng√†y Double Day):

| Ng√†y       | Ca    | Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng |
|------------|-------|--------------------------|
| 2025-05-05 | Ca 1  | NV A, NV B, NV X         | <--- 3 ng∆∞·ªùi v√¨ l√† ng√†y 5/5
| 2025-05-05 | Ca 2  | NV C, NV D, NV Y         | <--- 3 ng∆∞·ªùi v√¨ l√† ng√†y 5/5
| 2025-05-06 | Ca 1  | NV E, NV F               | <--- 2 ng∆∞·ªùi v√¨ l√† ng√†y th∆∞·ªùng
| ... (cho ƒë·∫øn 2025-05-11) ... | ...   | ...                      |

**QUAN TR·ªåNG:** Ch·ªâ tr·∫£ v·ªÅ B·∫¢NG MARKDOWN l·ªãch l√†m vi·ªác, kh√¥ng th√™m b·∫•t k·ª≥ l·ªùi gi·∫£i th√≠ch hay b√¨nh lu·∫≠n n√†o kh√°c tr∆∞·ªõc ho·∫∑c sau b·∫£ng. ƒê·∫£m b·∫£o c·ªôt "Ng√†y" ch·ª©a ng√†y YYYY-MM-DD ch√≠nh x√°c cho c·∫£ tu·∫ßn. **ƒê·∫£m b·∫£o x·ª≠ l√Ω c√°c 'Ghi ch√∫' theo h∆∞·ªõng d·∫´n ƒë√£ n√™u, ƒë·∫∑c bi·ªát l√† logic ∆∞u ti√™n cho gi·ªù l√†m kh√¥ng tr·ªçn v·∫πn.** ƒê·∫£m b·∫£o m·ªçi r√†ng bu·ªôc kh√°c ƒë∆∞·ª£c ƒë√°p ·ª©ng (ƒë·∫∑c bi·ªát l√† **s·ªë ng∆∞·ªùi/ca theo t·ª´ng ng√†y** nh∆∞ ƒë√£ n√™u ·ªü tr√™n, **M·ª§C TI√äU {requirements['shifts_per_week_target']} ca/ng∆∞·ªùi/tu·∫ßn PH·∫¢I ƒê∆Ø·ª¢C ∆ØU TI√äN T·ªêI ƒêA**, v√† {requirements['max_shifts_per_day']} ca/ng∆∞·ªùi/ng√†y).
N·∫øu kh√¥ng th·ªÉ t·∫°o l·ªãch ƒë√°p ·ª©ng t·∫•t c·∫£ r√†ng bu·ªôc (v√≠ d·ª•: thi·∫øu ng∆∞·ªùi cho m·ªôt ca n√†o ƒë√≥, ho·∫∑c kh√¥ng th·ªÉ ƒë·∫£m b·∫£o {requirements['shifts_per_week_target']} ca/tu·∫ßn cho m·ªçi ng∆∞·ªùi), h√£y ghi r√µ ƒëi·ªÅu ƒë√≥ trong b·∫£ng ho·∫∑c n√™u l√Ω do ng·∫Øn g·ªçn ngay d∆∞·ªõi b·∫£ng. **ƒê·∫∑c bi·ªát, n·∫øu m·ªôt ca kh√¥ng ƒë·ªß s·ªë ng∆∞·ªùi y√™u c·∫ßu (v√≠ d·ª•, c·∫ßn 2 ng∆∞·ªùi nh∆∞ng ch·ªâ x·∫øp ƒë∆∞·ª£c 1), h√£y ghi ch√∫ trong c·ªôt 'Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng' l√† 'T√™n NV ƒë∆∞·ª£c x·∫øp, (Thi·∫øu 1 ng∆∞·ªùi)' ho·∫∑c n·∫øu kh√¥ng c√≥ ai th√¨ ghi '(Thi·∫øu 2 ng∆∞·ªùi)' ho·∫∑c t∆∞∆°ng t·ª±.**
"""
    with st.expander("Xem Prompt g·ª≠i ƒë·∫øn AI (ƒë·ªÉ tham kh·∫£o)"):
        st.text(full_prompt)
    try:  # Call AI Model
        st.info("‚è≥ ƒêang g·ªçi AI ƒë·ªÉ t·∫°o l·ªãch...");
        response = model.generate_content(full_prompt)
        st.success("‚úÖ AI ƒë√£ ph·∫£n h·ªìi.");
        return response.text
    except Exception as e:
        st.error(f"L·ªói khi g·ªçi AI: {e}"); return None


# --- Function to Parse AI Response (Keep Improved Column Handling) ---
def parse_ai_schedule(ai_response_text):
    """Attempts to parse the AI's Markdown table response into a DataFrame."""
    st.info("üîé ƒêang ph√¢n t√≠ch ph·∫£n h·ªìi t·ª´ AI...")
    with st.expander("Xem ph·∫£n h·ªìi th√¥ t·ª´ AI"):
        st.text(ai_response_text)
    # C·ªë g·∫Øng t√¨m b·∫£ng Markdown, k·ªÉ c·∫£ khi c√≥ text th·ª´a xung quanh
    table_match = re.search(r"(\n?\|.*?\n(?:\|.*?\n)+)", ai_response_text, re.DOTALL)
    if not table_match:
        # N·∫øu kh√¥ng t√¨m th·∫•y b·∫£ng ho√†n ch·ªânh, th·ª≠ t√¨m c√°c d√≤ng b·∫Øt ƒë·∫ßu b·∫±ng '|'
        lines = [line.strip() for line in ai_response_text.strip().split('\n') if line.strip().startswith('|')]
        if len(lines) > 1:
            st.warning("Kh√¥ng t√¨m th·∫•y c·∫•u tr√∫c Markdown chu·∫©n, th·ª≠ ph√¢n t√≠ch c√°c d√≤ng b·∫Øt ƒë·∫ßu b·∫±ng '|'.")
            table_content = "\n".join(lines)
            # Ki·ªÉm tra xem c√≥ d√≤ng header h·ª£p l·ªá kh√¥ng (ch·ª©a √≠t nh·∫•t 2 d·∫•u g·∫°ch n·ªëi)
            if not re.search(r"\|.*-.*-.*\|", lines[1]):
                st.warning("D√≤ng header Markdown c√≥ v·∫ª kh√¥ng h·ª£p l·ªá, s·∫Ω c·ªë g·∫Øng th√™m header m·∫∑c ƒë·ªãnh.")
                # Th√™m header gi·∫£ ƒë·ªãnh n·∫øu d√≤ng th·ª© hai kh√¥ng ph·∫£i l√† d√≤ng ph√¢n c√°ch header
                table_content = "| Ng√†y | Ca | Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng |\n|---|---|---|\n" + table_content
        else:
            st.error("Kh√¥ng t√¨m th·∫•y ƒë·ªãnh d·∫°ng b·∫£ng Markdown trong ph·∫£n h·ªìi c·ªßa AI.")
            return None
    else:
        table_content = table_match.group(1).strip()
        # Ki·ªÉm tra l·∫°i header sau khi tr√≠ch xu·∫•t
        lines = table_content.split('\n')
        if len(lines) > 1 and not re.search(r"\|.*-.*-.*\|", lines[1]):  # Ki·ªÉm tra d√≤ng th·ª© 2 (index 1)
            st.warning("D√≤ng header Markdown sau khi tr√≠ch xu·∫•t c√≥ v·∫ª kh√¥ng h·ª£p l·ªá, s·∫Ω c·ªë g·∫Øng th√™m header m·∫∑c ƒë·ªãnh.")
            # Gi·∫£ ƒë·ªãnh d√≤ng ƒë·∫ßu l√† header data, ch√®n d√≤ng ph√¢n c√°ch
            table_content = lines[0] + "\n|---|---|---|\n" + "\n".join(lines[1:])

    try:
        data_io = io.StringIO(table_content)
        # ƒê·ªçc CSV, b·ªè qua c√°c d√≤ng tr·ªëng v√† d√≤ng kh√¥ng ph·∫£i l√† b·∫£ng
        df_schedule = pd.read_csv(data_io, sep='|', skipinitialspace=True, on_bad_lines='skip')

        # Lo·∫°i b·ªè c√°c c·ªôt v√† h√†ng tr·ªëng ho·∫∑c kh√¥ng h·ª£p l·ªá
        df_schedule = df_schedule.dropna(axis=1, how='all')  # B·ªè c·ªôt to√†n NaN
        if df_schedule.shape[1] > 0 and df_schedule.iloc[:,
                                        0].isnull().all():  # N·∫øu c·ªôt ƒë·∫ßu ti√™n to√†n NaN (th∆∞·ªùng do d·∫•u | ·ªü ƒë·∫ßu)
            df_schedule = df_schedule.iloc[:, 1:]
        if df_schedule.shape[1] > 0 and df_schedule.iloc[:,
                                        -1].isnull().all():  # N·∫øu c·ªôt cu·ªëi c√πng to√†n NaN (th∆∞·ªùng do d·∫•u | ·ªü cu·ªëi)
            df_schedule = df_schedule.iloc[:, :-1]

        df_schedule.columns = [col.strip() for col in df_schedule.columns]
        # Lo·∫°i b·ªè d√≤ng ph√¢n c√°ch c·ªßa Markdown (v√≠ d·ª•: |---|---|---|)
        df_schedule = df_schedule[~df_schedule.iloc[:, 0].astype(str).str.contains(r'--\s*--', na=False)]
        df_schedule = df_schedule.dropna(axis=0, how='all')  # B·ªè h√†ng to√†n NaN

        # ƒê·ªïi t√™n c·ªôt n·∫øu c·∫ßn
        expected_cols = ["Ng√†y", "Ca", "Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng"]
        if len(df_schedule.columns) >= 3:
            current_cols = df_schedule.columns.tolist()
            # Ki·ªÉm tra xem t√™n c·ªôt hi·ªán t·∫°i c√≥ v·∫ª h·ª£p l√Ω kh√¥ng
            # Ch·ªâ ƒë·ªïi t√™n n·∫øu t√™n c·ªôt hi·ªán t·∫°i kh√¥ng ch·ª©a c√°c t·ª´ kh√≥a mong ƒë·ª£i
            if not (expected_cols[0].lower() in current_cols[0].lower() and \
                    expected_cols[1].lower() in current_cols[1].lower() and \
                    expected_cols[2].lower() in current_cols[2].lower()):
                st.warning(f"T√™n c·ªôt t·ª´ AI kh√¥ng kh·ªõp ho√†n to√†n: {current_cols}. S·ª≠ d·ª•ng t√™n c·ªôt m·∫∑c ƒë·ªãnh.")
                df_schedule = df_schedule.iloc[:, :len(expected_cols)]  # Ch·ªâ l·∫•y ƒë·ªß s·ªë c·ªôt mong ƒë·ª£i
                df_schedule.columns = expected_cols[:len(df_schedule.columns)]
            else:  # N·∫øu t√™n c·ªôt c√≥ v·∫ª ·ªïn, ch·ªâ chu·∫©n h√≥a v√† l·∫•y 3 c·ªôt ch√≠nh
                df_schedule = df_schedule.iloc[:, :3]
                df_schedule.columns = expected_cols

        elif len(df_schedule.columns) == 2 and expected_cols[0].lower() in df_schedule.columns[0].lower() and \
                expected_cols[1].lower() in df_schedule.columns[1].lower():
            st.warning("B·∫£ng t·ª´ AI thi·∫øu c·ªôt 'Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'. S·∫Ω hi·ªÉn th·ªã v·ªõi c·ªôt ƒë√≥ tr·ªëng.")
            df_schedule["Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng"] = ""
            df_schedule.columns = expected_cols
        else:
            st.error(
                f"L·ªói ph√¢n t√≠ch: B·∫£ng ch·ªâ c√≥ {len(df_schedule.columns)} c·ªôt, c·∫ßn √≠t nh·∫•t 3 c·ªôt ('Ng√†y', 'Ca', 'Nh√¢n vi√™n').")
            st.dataframe(df_schedule)
            return None

        # L√†m s·∫°ch d·ªØ li·ªáu trong c√°c √¥
        for col in df_schedule.columns:
            if df_schedule[col].dtype == 'object':
                df_schedule[col] = df_schedule[col].str.strip()

        # Chuy·ªÉn ƒë·ªïi c·ªôt 'Ng√†y'
        if "Ng√†y" in df_schedule.columns:
            try:
                df_schedule['Ng√†y_str_backup'] = df_schedule['Ng√†y']  # Gi·ªØ l·∫°i gi√° tr·ªã string g·ªëc
                df_schedule['Ng√†y'] = pd.to_datetime(df_schedule['Ng√†y'], errors='coerce')
                if df_schedule['Ng√†y'].isnull().any():
                    st.warning(
                        "C·∫£nh b√°o: M·ªôt s·ªë gi√° tr·ªã 'Ng√†y' t·ª´ AI kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng YYYY-MM-DD. S·∫Ω c·ªë g·∫Øng chuy·ªÉn ƒë·ªïi l·∫°i t·ª´ ƒë·ªãnh d·∫°ng DD/MM/YYYY ho·∫∑c MM/DD/YYYY.")
                    for idx, row_data in df_schedule.iterrows():
                        if pd.isna(row_data['Ng√†y']):
                            try_formats = ['%d/%m/%Y', '%m/%d/%Y', '%Y/%m/%d', '%d-%m-%Y', '%m-%d-%Y']
                            for fmt in try_formats:
                                try:
                                    converted_date = pd.to_datetime(row_data['Ng√†y_str_backup'], format=fmt,
                                                                    errors='raise')
                                    df_schedule.loc[idx, 'Ng√†y'] = converted_date
                                    break  # Chuy·ªÉn ƒë·ªïi th√†nh c√¥ng
                                except (ValueError, TypeError):
                                    continue  # Th·ª≠ ƒë·ªãnh d·∫°ng ti·∫øp theo
                df_schedule = df_schedule.dropna(subset=['Ng√†y'])
                df_schedule.drop(columns=['Ng√†y_str_backup'], inplace=True, errors='ignore')
            except Exception as date_err:
                st.warning(
                    f"L·ªói chuy·ªÉn ƒë·ªïi c·ªôt 'Ng√†y' t·ª´ AI: {date_err}. Ki·ªÉm tra ƒë·ªãnh d·∫°ng ng√†y trong ph·∫£n h·ªìi c·ªßa AI.")
                df_schedule.drop(columns=['Ng√†y_str_backup'], inplace=True, errors='ignore')
        else:
            st.error("L·ªói nghi√™m tr·ªçng: Kh√¥ng t√¨m th·∫•y c·ªôt 'Ng√†y' trong b·∫£ng ph√¢n t√≠ch.")
            return None

        if df_schedule.empty:
            st.warning("Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá sau khi ph√¢n t√≠ch ph·∫£n h·ªìi t·ª´ AI.")
            return None

        st.success("‚úÖ Ph√¢n t√≠ch l·ªãch tr√¨nh t·ª´ AI th√†nh c√¥ng.");
        return df_schedule
    except Exception as e:
        st.error(f"L·ªói nghi√™m tr·ªçng khi ph√¢n t√≠ch b·∫£ng Markdown t·ª´ AI: {e}")
        st.info("Vui l√≤ng ki·ªÉm tra 'Ph·∫£n h·ªìi th√¥ t·ª´ AI' ·ªü tr√™n ƒë·ªÉ xem ƒë·ªãnh d·∫°ng AI tr·∫£ v·ªÅ.")
        return None


# --- Function to Display Formatted Schedule (Keep using Selectbox) ---
def display_editable_schedule_with_dropdowns(parsed_schedule_df, availability_df):
    """Displays the schedule using columns and selectboxes for editing."""
    st.subheader("üìÖ L·ªãch L√†m Vi·ªác Tu·∫ßn (Ch·ªânh s·ª≠a / Thay th·∫ø)")
    if parsed_schedule_df is None or parsed_schedule_df.empty: st.warning(
        "Kh√¥ng c√≥ d·ªØ li·ªáu l·ªãch ƒë·ªÉ hi·ªÉn th·ªã."); return None
    if availability_df is None or availability_df.empty:
        st.warning("Thi·∫øu d·ªØ li·ªáu tra c·ª©u ng∆∞·ªùi thay th·∫ø (availability_df tr·ªëng). Kh√¥ng th·ªÉ t·∫°o danh s√°ch ch·ªçn.")
        # Hi·ªÉn th·ªã b·∫£ng ch·ªâ ƒë·ªçc n·∫øu kh√¥ng c√≥ availability_df
        st.dataframe(create_8_column_df(parsed_schedule_df))
        return create_8_column_df(parsed_schedule_df)  # Tr·∫£ v·ªÅ b·∫£ng 8 c·ªôt kh√¥ng ch·ªânh s·ª≠a ƒë∆∞·ª£c

    try:
        # Ensure 'Ng√†y' is datetime
        if 'Ng√†y' in parsed_schedule_df.columns and not pd.api.types.is_datetime64_any_dtype(
                parsed_schedule_df['Ng√†y']):
            parsed_schedule_df['Ng√†y'] = pd.to_datetime(parsed_schedule_df['Ng√†y'], errors='coerce')
        # Lo·∫°i b·ªè c√°c d√≤ng c√≥ gi√° tr·ªã NaN trong c√°c c·ªôt quan tr·ªçng
        parsed_schedule_df = parsed_schedule_df.dropna(subset=['Ng√†y', 'Ca'])
        # ƒê·∫£m b·∫£o c·ªôt 'Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng' l√† string, thay NaN b·∫±ng chu·ªói r·ªóng
        if 'Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng' in parsed_schedule_df.columns:
            parsed_schedule_df['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'] = parsed_schedule_df['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'].fillna(
                '').astype(str)
        else:
            parsed_schedule_df['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'] = ""

        if parsed_schedule_df.empty: st.warning("Kh√¥ng c√≤n d·ªØ li·ªáu h·ª£p l·ªá sau khi l·ªçc."); return None

        # Get unique sorted dates
        unique_dates = sorted(parsed_schedule_df['Ng√†y'].dt.date.unique())
        if not unique_dates: st.warning("Kh√¥ng c√≥ ng√†y h·ª£p l·ªá n√†o trong d·ªØ li·ªáu."); return None

        col_names = ['Th·ª©', 'Ng√†y', 'Ca 1 (NV1)', 'Ca 1 (NV2)', 'Ca 1 (NV3)', 'Ca 2 (NV1)', 'Ca 2 (NV2)', 'Ca 2 (NV3)']
        col_widths = [0.6, 0.9, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]
        header_cols = st.columns(col_widths)
        for col, name in zip(header_cols, col_names):
            col.markdown(f"<div style='text-align: center; font-weight: bold;'>{name}</div>",
                         unsafe_allow_html=True)  # CƒÉn gi·ªØa v√† in ƒë·∫≠m header
        st.divider()

        if 'current_schedule_selections' not in st.session_state:
            st.session_state.current_schedule_selections = {}

        vietnamese_days = ["Th·ª© 2", "Th·ª© 3", "Th·ª© 4", "Th·ª© 5", "Th·ª© 6", "Th·ª© 7", "Ch·ªß Nh·∫≠t"]
        edited_data = []

        all_available_employees = [""] + sorted(
            list(set(availability_df['Employee'].unique().tolist())))  # Danh s√°ch chung, ƒë·∫£m b·∫£o duy nh·∫•t

        for current_date_obj in unique_dates:  # ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ r√µ r√†ng h∆°n
            row_cols = st.columns(col_widths)
            day_name = vietnamese_days[current_date_obj.weekday()]
            date_str = current_date_obj.strftime('%d/%m/%Y')
            row_cols[0].markdown(
                f"<div style='text-align: center; height: 100%; display: flex; align-items: center; justify-content: center;'>{day_name}</div>",
                unsafe_allow_html=True)
            row_cols[1].markdown(
                f"<div style='text-align: center; height: 100%; display: flex; align-items: center; justify-content: center;'>{date_str}</div>",
                unsafe_allow_html=True)

            # --- Process Ca 1 ---
            ca1_data = parsed_schedule_df[
                (parsed_schedule_df['Ng√†y'].dt.date == current_date_obj) & (parsed_schedule_df['Ca'] == 'Ca 1')]
            staff_ca1_str = ca1_data['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'].iloc[0] if not ca1_data.empty else ""
            initial_staff_ca1 = [name.strip() for name in staff_ca1_str.split(',') if
                                 name.strip() and not "(Thi·∫øu" in name]  # B·ªè qua ghi ch√∫ thi·∫øu ng∆∞·ªùi

            available_ca1_df = availability_df[
                (availability_df['Date'] == current_date_obj) & (availability_df['Shift'] == 'Ca 1') & (
                            availability_df['Can_Work'] == True)]
            available_ca1_list = [""] + sorted(list(set(available_ca1_df['Employee'].unique().tolist())))

            # Th√™m c√°c nh√¢n vi√™n ƒë√£ ƒë∆∞·ª£c AI x·∫øp v√†o danh s√°ch ch·ªçn, n·∫øu h·ªç ch∆∞a c√≥
            for emp in initial_staff_ca1:
                if emp not in available_ca1_list:
                    available_ca1_list.append(emp)
            available_ca1_list = sorted(list(set(available_ca1_list)))  # S·∫Øp x·∫øp l·∫°i v√† ƒë·∫£m b·∫£o duy nh·∫•t

            if len(available_ca1_list) == 1 and available_ca1_list[0] == "":  # N·∫øu ch·ªâ c√≥ l·ª±a ch·ªçn r·ªóng
                options_list_c1 = all_available_employees  # Fallback n·∫øu kh√¥ng ai ƒëƒÉng k√Ω ca n√†y
            else:
                options_list_c1 = available_ca1_list

            selected_ca1 = []
            for i in range(3):  # NV1, NV2, NV3 for Ca 1
                col_index = i + 2
                selectbox_key = f"ca1_nv{i + 1}_{date_str}_{current_date_obj.year}"
                initial_selection = initial_staff_ca1[i] if i < len(initial_staff_ca1) else ""
                current_selection_val = st.session_state.current_schedule_selections.get(selectbox_key,
                                                                                         initial_selection)

                if current_selection_val not in options_list_c1:
                    current_selection_val = options_list_c1[0] if options_list_c1 else ""

                try:
                    selected_index_c1 = options_list_c1.index(current_selection_val)
                except ValueError:
                    selected_index_c1 = 0

                selected_emp_c1 = row_cols[col_index].selectbox(f"Ca 1 NV{i + 1} {date_str}", options=options_list_c1,
                                                                index=selected_index_c1, key=selectbox_key,
                                                                label_visibility="collapsed")
                selected_ca1.append(selected_emp_c1)
                st.session_state.current_schedule_selections[selectbox_key] = selected_emp_c1

            # --- Process Ca 2 ---
            ca2_data = parsed_schedule_df[
                (parsed_schedule_df['Ng√†y'].dt.date == current_date_obj) & (parsed_schedule_df['Ca'] == 'Ca 2')]
            staff_ca2_str = ca2_data['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'].iloc[0] if not ca2_data.empty else ""
            initial_staff_ca2 = [name.strip() for name in staff_ca2_str.split(',') if
                                 name.strip() and not "(Thi·∫øu" in name]

            available_ca2_df = availability_df[
                (availability_df['Date'] == current_date_obj) & (availability_df['Shift'] == 'Ca 2') & (
                            availability_df['Can_Work'] == True)]
            available_ca2_list = [""] + sorted(list(set(available_ca2_df['Employee'].unique().tolist())))

            for emp in initial_staff_ca2:
                if emp not in available_ca2_list:
                    available_ca2_list.append(emp)
            available_ca2_list = sorted(list(set(available_ca2_list)))

            if len(available_ca2_list) == 1 and available_ca2_list[0] == "":
                options_list_c2 = all_available_employees
            else:
                options_list_c2 = available_ca2_list

            selected_ca2 = []
            for i in range(3):  # NV1, NV2, NV3 for Ca 2
                col_index = i + 5
                selectbox_key = f"ca2_nv{i + 1}_{date_str}_{current_date_obj.year}"
                initial_selection = initial_staff_ca2[i] if i < len(initial_staff_ca2) else ""
                current_selection_val = st.session_state.current_schedule_selections.get(selectbox_key,
                                                                                         initial_selection)

                if current_selection_val not in options_list_c2:
                    current_selection_val = options_list_c2[0] if options_list_c2 else ""

                try:
                    selected_index_c2 = options_list_c2.index(current_selection_val)
                except ValueError:
                    selected_index_c2 = 0

                selected_emp_c2 = row_cols[col_index].selectbox(f"Ca 2 NV{i + 1} {date_str}", options=options_list_c2,
                                                                index=selected_index_c2, key=selectbox_key,
                                                                label_visibility="collapsed")
                selected_ca2.append(selected_emp_c2)
                st.session_state.current_schedule_selections[selectbox_key] = selected_emp_c2

            edited_row = {
                'Th·ª©': day_name, 'Ng√†y': date_str,
                'Ca 1 (NV1)': selected_ca1[0], 'Ca 1 (NV2)': selected_ca1[1], 'Ca 1 (NV3)': selected_ca1[2],
                'Ca 2 (NV1)': selected_ca2[0], 'Ca 2 (NV2)': selected_ca2[1], 'Ca 2 (NV3)': selected_ca2[2],
            }
            edited_data.append(edited_row)
            st.divider()

        return pd.DataFrame(edited_data)

    except Exception as e:
        st.error(f"L·ªói khi t·∫°o/hi·ªÉn th·ªã b·∫£ng ch·ªânh s·ª≠a: {e}")
        st.exception(e)  # In chi ti·∫øt l·ªói ƒë·ªÉ debug
        st.write("D·ªØ li·ªáu DataFrame g·ªëc t·ª´ AI (parsed_schedule_df):")
        st.dataframe(parsed_schedule_df)
        st.write("D·ªØ li·ªáu tra c·ª©u (availability_df):")
        st.dataframe(availability_df)
        return create_8_column_df(parsed_schedule_df)  # Tr·∫£ v·ªÅ b·∫£ng 8 c·ªôt kh√¥ng ch·ªânh s·ª≠a ƒë∆∞·ª£c n·∫øu l·ªói


# --- Function to Create 8-Column DataFrame (Helper Function) ---
def create_8_column_df(df_schedule):
    """Creates the 8-column display DataFrame from the parsed 3-column schedule."""
    if df_schedule is None or df_schedule.empty: return pd.DataFrame(
        columns=['Th·ª©', 'Ng√†y', 'Ca 1 (NV1)', 'Ca 1 (NV2)', 'Ca 1 (NV3)', 'Ca 2 (NV1)', 'Ca 2 (NV2)', 'Ca 2 (NV3)'])
    try:
        if 'Ng√†y' in df_schedule.columns and not pd.api.types.is_datetime64_any_dtype(df_schedule['Ng√†y']):
            df_schedule['Ng√†y'] = pd.to_datetime(df_schedule['Ng√†y'], errors='coerce')
        df_schedule = df_schedule.dropna(subset=['Ng√†y', 'Ca'])
        if 'Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng' in df_schedule.columns:
            df_schedule['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'] = df_schedule['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'].fillna('').astype(str)
        else:
            df_schedule['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'] = ""

        if df_schedule.empty: return pd.DataFrame(
            columns=['Th·ª©', 'Ng√†y', 'Ca 1 (NV1)', 'Ca 1 (NV2)', 'Ca 1 (NV3)', 'Ca 2 (NV1)', 'Ca 2 (NV2)', 'Ca 2 (NV3)'])
        unique_dates = sorted(df_schedule['Ng√†y'].dt.date.unique())
        if not unique_dates: return pd.DataFrame(
            columns=['Th·ª©', 'Ng√†y', 'Ca 1 (NV1)', 'Ca 1 (NV2)', 'Ca 1 (NV3)', 'Ca 2 (NV1)', 'Ca 2 (NV2)', 'Ca 2 (NV3)'])

        output_rows = []
        vietnamese_days = ["Th·ª© 2", "Th·ª© 3", "Th·ª© 4", "Th·ª© 5", "Th·ª© 6", "Th·ª© 7", "Ch·ªß Nh·∫≠t"]
        for current_date_obj in unique_dates:  # ƒê·ªïi t√™n bi·∫øn
            day_name = vietnamese_days[current_date_obj.weekday()]
            date_str = current_date_obj.strftime('%d/%m/%Y')

            ca1_data = df_schedule[(df_schedule['Ng√†y'].dt.date == current_date_obj) & (df_schedule['Ca'] == 'Ca 1')]
            staff_ca1_str = ca1_data['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'].iloc[0] if not ca1_data.empty else ""
            staff_ca1_list = [name.strip() for name in staff_ca1_str.split(',') if name.strip()]

            ca2_data = df_schedule[(df_schedule['Ng√†y'].dt.date == current_date_obj) & (df_schedule['Ca'] == 'Ca 2')]
            staff_ca2_str = ca2_data['Nh√¢n vi√™n ƒë∆∞·ª£c ph√¢n c√¥ng'].iloc[0] if not ca2_data.empty else ""
            staff_ca2_list = [name.strip() for name in staff_ca2_str.split(',') if name.strip()]

            row_data = {
                'Th·ª©': day_name, 'Ng√†y': date_str,
                'Ca 1 (NV1)': staff_ca1_list[0] if len(staff_ca1_list) > 0 else '',
                'Ca 1 (NV2)': staff_ca1_list[1] if len(staff_ca1_list) > 1 else '',
                'Ca 1 (NV3)': staff_ca1_list[2] if len(staff_ca1_list) > 2 else '',
                'Ca 2 (NV1)': staff_ca2_list[0] if len(staff_ca2_list) > 0 else '',
                'Ca 2 (NV2)': staff_ca2_list[1] if len(staff_ca2_list) > 1 else '',
                'Ca 2 (NV3)': staff_ca2_list[2] if len(staff_ca2_list) > 2 else '',
            }
            output_rows.append(row_data)
        df_display = pd.DataFrame(output_rows)
        column_order = ['Th·ª©', 'Ng√†y', 'Ca 1 (NV1)', 'Ca 1 (NV2)', 'Ca 1 (NV3)', 'Ca 2 (NV1)', 'Ca 2 (NV2)',
                        'Ca 2 (NV3)']
        # ƒê·∫£m b·∫£o t·∫•t c·∫£ c√°c c·ªôt ƒë·ªÅu t·ªìn t·∫°i, n·∫øu kh√¥ng th√¨ t·∫°o c·ªôt tr·ªëng
        for col in column_order:
            if col not in df_display.columns:
                df_display[col] = ''
        df_display = df_display[column_order]
        return df_display
    except Exception as e:
        st.error(f"L·ªói khi t·∫°o b·∫£ng 8 c·ªôt (helper): {e}")
        return pd.DataFrame(
            columns=['Th·ª©', 'Ng√†y', 'Ca 1 (NV1)', 'Ca 1 (NV2)', 'Ca 1 (NV3)', 'Ca 2 (NV1)', 'Ca 2 (NV2)', 'Ca 2 (NV3)'])


# --- Main Application Logic (UPDATED State Management and Display Logic) ---
def main_app():
    """Main application function after login."""
    load_css()
    st.title("üìÖ AI Work Schedule Manager")
    st.caption("D√°n d·ªØ li·ªáu ƒëƒÉng k√Ω t·ª´ Excel v√† ƒë·ªÉ AI t·∫°o l·ªãch l√†m vi·ªác t·ªëi ∆∞u.")
    st.divider()

    # Initialize session state
    if 'df_from_paste' not in st.session_state: st.session_state.df_from_paste = None
    if 'schedule_df' not in st.session_state: st.session_state.schedule_df = None  # Parsed 3-column AI result
    if 'edited_schedule_table' not in st.session_state: st.session_state.edited_schedule_table = None  # Stores the DF from the manual table
    if 'ai_response_text' not in st.session_state: st.session_state.ai_response_text = None
    if 'availability_lookup_df' not in st.session_state: st.session_state.availability_lookup_df = pd.DataFrame(
        columns=['Date', 'Employee', 'Shift', 'Can_Work', 'Note'])
    if 'copyable_text' not in st.session_state: st.session_state.copyable_text = None
    if 'current_schedule_selections' not in st.session_state: st.session_state.current_schedule_selections = {}

    requirements = get_scheduling_requirements()
    if requirements is None: st.stop()
    input_container = st.container(border=True)
    with input_container:
        st.subheader("üìã B∆∞·ªõc 1: D√°n D·ªØ Li·ªáu ƒêƒÉng K√Ω")
        col1, col2 = st.columns([3, 1])
        with col1: pasted_data = st.text_area("D√°n d·ªØ li·ªáu t·ª´ b·∫£ng Excel (sao ch√©p tr·ª±c ti·∫øp t·ª´ Excel):", height=250,
                                              key="pasted_data_area", label_visibility="collapsed")
        with col2:
            st.markdown("<div style='margin-top: 30px;'></div>", unsafe_allow_html=True)
            process_button = st.button("‚öôÔ∏è X·ª≠ l√Ω d·ªØ li·ªáu", key="process_paste_button", use_container_width=True)
            st.markdown("<div style='margin-top: 10px;'></div>", unsafe_allow_html=True)
            generate_button_placeholder = st.empty()

    if process_button:
        st.session_state.df_from_paste = None;
        st.session_state.schedule_df = None;
        st.session_state.edited_schedule_table = None;
        st.session_state.ai_response_text = None;
        st.session_state.availability_lookup_df = pd.DataFrame(
            columns=['Date', 'Employee', 'Shift', 'Can_Work', 'Note'])  # Reset
        st.session_state.current_schedule_selections = {}
        st.session_state.copyable_text = None
        if pasted_data:
            try:
                data_io = io.StringIO(pasted_data)
                # C·ªë g·∫Øng ƒë·ªçc v·ªõi header, n·∫øu l·ªói th√¨ ƒë·ªçc kh√¥ng header
                try:
                    temp_df = pd.read_csv(data_io, sep='\t', header=0, skipinitialspace=True)
                    # Ki·ªÉm tra xem header c√≥ h·ª£p l·ªá kh√¥ng (v√≠ d·ª•: ch·ª©a t·ª´ kh√≥a)
                    header_keywords = ["t√™n", "th·ª©", "ghi ch√∫", "tu·∫ßn", "ng√†y"]
                    if not any(keyword in str(col).lower() for col in temp_df.columns for keyword in header_keywords):
                        st.info("Ti√™u ƒë·ªÅ kh√¥ng kh·ªõp v·ªõi t·ª´ kh√≥a mong ƒë·ª£i, th·ª≠ ƒë·ªçc l·∫°i kh√¥ng c√≥ ti√™u ƒë·ªÅ.")
                        data_io.seek(0)  # Reset l·∫°i con tr·ªè file
                        temp_df = pd.read_csv(data_io, sep='\t', header=None, names=PREDEFINED_COLUMNS,
                                              skipinitialspace=True)
                        st.info("ƒê√£ s·ª≠ d·ª•ng t√™n c·ªôt m·∫∑c ƒë·ªãnh.")
                    else:
                        st.info("ƒê√£ ƒë·ªçc d·ªØ li·ªáu v·ªõi ti√™u ƒë·ªÅ t·ª´ ng∆∞·ªùi d√πng.")
                except pd.errors.ParserError:  # X·∫£y ra khi s·ªë c·ªôt kh√¥ng kh·ªõp header
                    st.warning("L·ªói khi ƒë·ªçc v·ªõi ti√™u ƒë·ªÅ (s·ªë c·ªôt kh√¥ng kh·ªõp). Th·ª≠ ƒë·ªçc kh√¥ng c√≥ ti√™u ƒë·ªÅ.")
                    data_io.seek(0)
                    temp_df = pd.read_csv(data_io, sep='\t', header=None, names=PREDEFINED_COLUMNS,
                                          skipinitialspace=True)
                    st.info("ƒê√£ s·ª≠ d·ª•ng t√™n c·ªôt m·∫∑c ƒë·ªãnh.")
                except Exception:  # C√°c l·ªói kh√°c khi ƒë·ªçc v·ªõi header
                    st.warning("L·ªói khi ƒë·ªçc v·ªõi ti√™u ƒë·ªÅ. Th·ª≠ ƒë·ªçc kh√¥ng c√≥ ti√™u ƒë·ªÅ.")
                    data_io.seek(0)
                    temp_df = pd.read_csv(data_io, sep='\t', header=None, names=PREDEFINED_COLUMNS,
                                          skipinitialspace=True)
                    st.info("ƒê√£ s·ª≠ d·ª•ng t√™n c·ªôt m·∫∑c ƒë·ªãnh.")

                temp_df.dropna(axis=0, how='all', inplace=True);
                temp_df.dropna(axis=1, how='all', inplace=True)
                if not temp_df.empty:
                    st.session_state.df_from_paste = temp_df;
                    st.success("‚úÖ ƒê√£ x·ª≠ l√Ω d·ªØ li·ªáu d√°n th√†nh c√¥ng.")
                    # T·∫°o b·∫£ng tra c·ª©u availability_lookup_df
                    st.session_state.availability_lookup_df = preprocess_pasted_data_for_lookup(
                        st.session_state.df_from_paste)
                    if st.session_state.availability_lookup_df is None or st.session_state.availability_lookup_df.empty:
                        st.warning(
                            "‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫°o b·∫£ng tra c·ª©u l·ªãch ƒëƒÉng k√Ω (availability_lookup_df). Ch·ª©c nƒÉng ch·ªânh s·ª≠a l·ªãch c√≥ th·ªÉ b·ªã h·∫°n ch·∫ø.")
                        st.session_state.availability_lookup_df = pd.DataFrame(
                            columns=['Date', 'Employee', 'Shift', 'Can_Work', 'Note'])  # Kh·ªüi t·∫°o l·∫°i ƒë·ªÉ tr√°nh l·ªói
                else:
                    st.warning("‚ö†Ô∏è D·ªØ li·ªáu sau khi x·ª≠ l√Ω b·ªã r·ªóng.")
            except pd.errors.EmptyDataError:
                st.warning("‚ö†Ô∏è D·ªØ li·ªáu d√°n v√†o tr·ªëng.")
            except Exception as e:
                st.error(f"‚ùå L·ªói khi ƒë·ªçc d·ªØ li·ªáu: {e}"); st.error(
                    "M·∫πo: ƒê·∫£m b·∫£o copy ƒë√∫ng v√πng B·∫¢NG (tab-separated)."); st.exception(e)
        else:
            st.warning("‚ö†Ô∏è Ch∆∞a c√≥ d·ªØ li·ªáu n√†o ƒë∆∞·ª£c d√°n v√†o.")

    if st.session_state.df_from_paste is not None:
        with st.container(border=True):
            st.subheader("üìÑ B∆∞·ªõc 2: Ki·ªÉm Tra D·ªØ Li·ªáu G·ªëc")
            st.dataframe(st.session_state.df_from_paste, use_container_width=True, height=300)  # Gi·ªõi h·∫°n chi·ªÅu cao
            if not st.session_state.df_from_paste.empty:
                if generate_button_placeholder.button("‚ú® T·∫°o L·ªãch v·ªõi AI", key="generate_ai_button",
                                                      use_container_width=True):
                    with st.spinner("‚è≥ ƒêang y√™u c·∫ßu AI t·∫°o l·ªãch..."):
                        ai_response = generate_schedule_with_ai(st.session_state.df_from_paste, requirements, model)
                        st.session_state.ai_response_text = ai_response;
                        st.session_state.schedule_df = None;
                        st.session_state.edited_schedule_table = None
                        st.session_state.current_schedule_selections = {}
                        st.session_state.copyable_text = None
                        if ai_response:
                            parsed_df = parse_ai_schedule(ai_response)
                            if parsed_df is not None and not parsed_df.empty:
                                st.session_state.schedule_df = parsed_df
                                # T·∫°o b·∫£ng 8 c·ªôt ban ƒë·∫ßu t·ª´ k·∫øt qu·∫£ AI
                                st.session_state.edited_schedule_table = create_8_column_df(
                                    st.session_state.schedule_df)
                            else:
                                st.error("‚ùå Kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c l·ªãch t·ª´ AI ho·∫∑c l·ªãch tr·ªëng.")
                                st.session_state.schedule_df = None  # ƒê·∫£m b·∫£o l√† None n·∫øu l·ªói
                                st.session_state.edited_schedule_table = create_8_column_df(None)  # T·∫°o b·∫£ng tr·ªëng
                        else:
                            st.error("‚ùå Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ AI.")
                            st.session_state.edited_schedule_table = create_8_column_df(None)  # T·∫°o b·∫£ng tr·ªëng
            else:
                st.info("D·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω tr·ªëng, kh√¥ng th·ªÉ t·∫°o l·ªãch.")

    # --- Display Result Section ---
    # Lu√¥n hi·ªÉn th·ªã khu v·ª±c n√†y n·∫øu edited_schedule_table ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o (k·ªÉ c·∫£ khi n√≥ r·ªóng)
    if st.session_state.get('edited_schedule_table') is not None:
        with st.container(border=True):
            # Hi·ªÉn th·ªã b·∫£ng ch·ªânh s·ª≠a, truy·ªÅn c·∫£ schedule_df (k·∫øt qu·∫£ g·ªëc t·ª´ AI) v√† availability_lookup_df
            # H√†m display_editable_schedule_with_dropdowns s·∫Ω c·∫≠p nh·∫≠t st.session_state.edited_schedule_table
            # n·∫øu c√≥ s·ª± thay ƒë·ªïi t·ª´ ng∆∞·ªùi d√πng th√¥ng qua st.session_state.current_schedule_selections
            current_edited_df = display_editable_schedule_with_dropdowns(
                st.session_state.schedule_df,  # D·ªØ li·ªáu g·ªëc t·ª´ AI ƒë·ªÉ kh·ªüi t·∫°o
                st.session_state.availability_lookup_df
            )
            if current_edited_df is not None:
                st.session_state.edited_schedule_table = current_edited_df

        st.divider()
        with st.container(border=True):
            st.subheader("üìù Sao Ch√©p D·ªØ Li·ªáu L·ªãch")
            copy_text_button = st.button("T·∫°o vƒÉn b·∫£n ƒë·ªÉ Copy sang Excel/Sheet", key="generate_copy_text_button",
                                         use_container_width=True)
            if copy_text_button:
                df_to_copy = st.session_state.get('edited_schedule_table', None)
                if df_to_copy is not None and not df_to_copy.empty:
                    try:
                        copy_string = df_to_copy.to_csv(sep='\t', index=False, header=True)
                        st.session_state.copyable_text = copy_string
                    except Exception as e:
                        st.error(f"L·ªói khi t·∫°o vƒÉn b·∫£n ƒë·ªÉ copy: {e}")
                        st.session_state.copyable_text = None
                else:
                    st.warning("Kh√¥ng c√≥ d·ªØ li·ªáu l·ªãch ƒë√£ ch·ªânh s·ª≠a ƒë·ªÉ t·∫°o vƒÉn b·∫£n ho·∫∑c l·ªãch tr·ªëng.")
                    st.session_state.copyable_text = None

            if st.session_state.copyable_text:
                st.text_area(
                    "Copy to√†n b·ªô n·ªôi dung d∆∞·ªõi ƒë√¢y (Ctrl+A, Ctrl+C) v√† d√°n v√†o √¥ A1 c·ªßa Excel/Sheet:",
                    st.session_state.copyable_text,
                    height=200,
                    key="copy_text_output"
                )

        st.divider();
        st.subheader("üì• T·∫£i Xu·ªëng L·ªãch (8 C·ªôt - ƒê√£ Ch·ªânh S·ª≠a)")
        col_dl1, col_dl2 = st.columns(2)

        df_to_download_final = st.session_state.get('edited_schedule_table', None)

        if df_to_download_final is not None and not df_to_download_final.empty:
            try:
                csv_8col = df_to_download_final.to_csv(index=False, encoding='utf-8-sig')
                col_dl1.download_button("T·∫£i CSV (ƒê√£ s·ª≠a)", csv_8col, "edited_schedule_8col.csv", "text/csv",
                                        use_container_width=True, key="dl_csv_8col_edit")
            except Exception as e:
                col_dl1.error(f"L·ªói CSV 8 c·ªôt: {e}")
            try:
                buffer_excel_8col = io.BytesIO()
                engine = 'xlsxwriter' if 'xlsxwriter' in sys.modules else 'openpyxl'
                with pd.ExcelWriter(buffer_excel_8col, engine=engine) as writer:
                    df_to_download_final.to_excel(writer, index=False, sheet_name='Edited_Schedule_8Col')
                col_dl2.download_button("T·∫£i Excel (ƒê√£ s·ª≠a)", buffer_excel_8col.getvalue(), "edited_schedule_8col.xlsx",
                                        "application/vnd.ms-excel", use_container_width=True, key="dl_excel_8col_edit")
            except Exception as e:
                col_dl2.error(f"L·ªói Excel 8 c·ªôt: {e}")
        else:
            col_dl1.warning("Kh√¥ng c√≥ d·ªØ li·ªáu l·ªãch ƒë√£ s·ª≠a ƒë·ªÉ t·∫£i ho·∫∑c l·ªãch tr·ªëng.")
            col_dl2.warning("Kh√¥ng c√≥ d·ªØ li·ªáu l·ªãch ƒë√£ s·ª≠a ƒë·ªÉ t·∫£i ho·∫∑c l·ªãch tr·ªëng.")

    st.sidebar.divider()
    st.sidebar.markdown("<p class='footer-copyright'>Copyright ¬©LeQuyPhat</p>", unsafe_allow_html=True)


# --- Entry Point ---
def main():
    """Main function to handle login state."""
    if 'logged_in' not in st.session_state: st.session_state.logged_in = False
    load_css()
    if not st.session_state.logged_in:
        login()
    else:
        main_app()


if __name__ == "__main__":
    main()
